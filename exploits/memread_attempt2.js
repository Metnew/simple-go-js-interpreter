// Attempt 2: Memory read via various Go runtime interaction vectors
// Focus: int(Infinity) UB, panic recovery info, stack traces, type confusion

_print("=== Vector 1: copyWithin with int(Infinity) UB ===");
// int(toInteger(Infinity)) → int(+Inf) → implementation-defined in Go
// On amd64: int(+Inf) = MinInt64 = -9223372036854775808
// This causes negative index → Go runtime panic
// In test runner context, recover() catches it and we get the error message

var arr = [1, 2, 3, 4, 5];
try {
    // start=Infinity → int(+Inf) → MinInt64 → negative → length + MinInt64 → still negative
    // Go panic: runtime error: slice bounds out of range
    arr.copyWithin(0, Infinity, 10);
    _print("  No crash (unexpected)");
} catch(e) {
    _print("  Error: " + e);
    _print("  Message: " + e.message);
    if (e.stack) _print("  Stack: " + e.stack);
}

try {
    arr.copyWithin(0, -Infinity, 5);
    _print("  No crash for -Infinity (unexpected)");
} catch(e) {
    _print("  -Inf Error: " + e);
}

// Try with very large finite number
try {
    arr.copyWithin(0, 1e18, 1e18 + 100);
    _print("  No crash for 1e18 (unexpected)");
} catch(e) {
    _print("  1e18 Error: " + e);
}

_print("\n=== Vector 2: Array.fill with int(Infinity) ===");
try {
    var arr2 = [1, 2, 3];
    arr2.fill("X", Infinity, Infinity);
    _print("  fill(X, Inf, Inf): " + arr2);
} catch(e) {
    _print("  Error: " + e);
}

try {
    var arr3 = [1, 2, 3];
    // fill with start=-Infinity → int(-Inf) → MinInt64 → still negative after +length
    arr3.fill("X", -Infinity, 2);
    _print("  fill(X, -Inf, 2): " + arr3);
} catch(e) {
    _print("  -Inf fill Error: " + e);
}

_print("\n=== Vector 3: Stack overflow → Go stack trace leak ===");
// Deep recursion causes Go stack overflow
// In test runner context, recover() catches this:
//   panic: runtime: goroutine stack exceeds 1000000000-byte limit
//   runtime.goexit()
//     /usr/local/go/src/runtime/asm_amd64.s:1695 +0x1
// This leaks: Go version, GOROOT path, goroutine addresses
try {
    function recurse(n) { return recurse(n + 1); }
    recurse(0);
} catch(e) {
    _print("  Recursion error: " + e);
    if (e.message) _print("  Message: " + e.message);
    if (e.stack) _print("  Stack: " + e.stack);
}

_print("\n=== Vector 4: toString/valueOf override for type confusion ===");
// Override valueOf to return unexpected types during internal operations
var evil = {
    valueOf: function() {
        // When the engine calls toNumber(evil), it calls evil.valueOf()
        // If we return a Symbol, the engine might call Symbol.Key() internally
        return Symbol("leak_via_valueOf");
    },
    toString: function() {
        return Symbol.iterator.toString();
    }
};

// Try to use evil as an array index → triggers ToPropertyKey → might leak
try {
    var target = {};
    target[evil] = "test";
    var keys = Object.getOwnPropertyNames(target);
    _print("  target keys via evil valueOf: " + keys);
    var ki = 0;
    while (ki < keys.length) {
        if (keys[ki].indexOf("0x") >= 0 || keys[ki].indexOf("@@sym") >= 0) {
            _print("  [!] Leaked key: " + keys[ki]);
        }
        ki++;
    }
} catch(e) {
    _print("  valueOf override error: " + e);
}

_print("\n=== Vector 5: Go type leak via unsupported AST nodes ===");
// Trigger "unsupported statement: %T" or "unsupported expression: %T"
// which reveals Go package paths and type names
try {
    // Generator functions might not be fully supported
    eval("function* gen() { yield 1; }");
    _print("  generator: supported");
} catch(e) {
    _print("  generator error: " + e);
    // Look for Go type name in error
    if (String(e).indexOf("ast.") >= 0 || String(e).indexOf("*") >= 0) {
        _print("  [!] Go type leaked: " + e);
    }
}

try {
    eval("async function af() { await 1; }");
    _print("  async: supported");
} catch(e) {
    _print("  async error: " + e);
    if (String(e).indexOf("ast.") >= 0) {
        _print("  [!] Go type leaked: " + e);
    }
}

try {
    eval("class Foo { #x = 1; }");
    _print("  private field: supported");
} catch(e) {
    _print("  private field error: " + e);
}

_print("\n=== Vector 6: Null byte in property name ===");
// Go strings can contain null bytes. If property names with nulls
// are handled differently at different layers, we might get confusion
try {
    var obj6 = {};
    var key_with_null = "before\0after";
    obj6[key_with_null] = "value";
    _print("  Set key with \\0: success");
    _print("  Get full key: " + obj6[key_with_null]);
    _print("  Get 'before': " + obj6["before"]);
    _print("  Get 'before\\0after': " + obj6["before\0after"]);
    // If C-style null termination is used somewhere, 'before' might match 'before\0after'
    var keys6 = Object.getOwnPropertyNames(obj6);
    _print("  Keys: " + JSON.stringify(keys6));
    _print("  Key length: " + keys6[0].length + " (expected: " + key_with_null.length + ")");
} catch(e) {
    _print("  Null byte error: " + e);
}

_print("\n=== Vector 7: Map key with object → Go pointer in key ===");
// When using objects as Map keys, Go stores *Object pointers
// If we can somehow stringify the Map's internal state...
try {
    var m = new Map();
    var key7 = {};
    m.set(key7, "secret");
    // Try to get the Map to reveal its internal Go structure
    _print("  Map size: " + m.size);
    _print("  Map toString: " + m.toString());
    _print("  Map keys type: " + typeof m.keys);
    // Try JSON.stringify - might trigger Go struct formatting
    try {
        _print("  JSON.stringify(Map): " + JSON.stringify(m));
    } catch(je) {
        _print("  JSON.stringify error: " + je);
    }
} catch(e) {
    _print("  Map error: " + e);
}

_print("\n=== Vector 8: Reflect.get on proxy internals ===");
// Try to access Proxy internal slots [[Target]] and [[Handler]]
try {
    var target8 = {secret: 42};
    var handler8 = {
        get: function(t, p) { return "intercepted_" + p; }
    };
    var p8 = new Proxy(target8, handler8);
    // Can we access the target through the proxy?
    _print("  Proxy.secret: " + p8.secret);
    _print("  Proxy keys: " + Object.getOwnPropertyNames(p8));
    // Try to get internal [[Target]]
    _print("  Proxy.__target: " + p8.__target);
    _print("  Proxy.[[Target]]: " + p8["[[Target]]"]);
    // Try Reflect
    _print("  Reflect.get(proxy, 'secret'): " + Reflect.get(p8, "secret"));
} catch(e) {
    _print("  Proxy error: " + e);
}

_print("\n=== Vector 9: Error.captureStackTrace (V8-style) ===");
try {
    if (Error.captureStackTrace) {
        var obj9 = {};
        Error.captureStackTrace(obj9);
        _print("  captureStackTrace: " + obj9.stack);
    } else {
        _print("  captureStackTrace: not available");
    }
} catch(e) {
    _print("  captureStackTrace error: " + e);
}

_print("\n=== Vector 10: Number edge cases in array access ===");
// Test if -0, 0x80000000, and other special numbers cause issues
var arr10 = [10, 20, 30, 40, 50];
try {
    _print("  arr[-0]: " + arr10[-0]);
    _print("  arr[0x80000000]: " + arr10[0x80000000]);
    _print("  arr[4294967295]: " + arr10[4294967295]);
    _print("  arr[4294967296]: " + arr10[4294967296]);
    _print("  arr[NaN]: " + arr10[NaN]);
    _print("  arr[undefined]: " + arr10[undefined]);
} catch(e) {
    _print("  Number edge error: " + e);
}

_print("\n=== DONE ===");
