// Attempt 4: Final creative vectors for memory read primitive
// Focus: Go internal type leaks, iterator abuse, constructor confusion

_print("=== Vector 1: Trigger 'unsupported statement/expression: %T' ===");
// fmt.Sprintf("unsupported statement: %T", stmt) leaks Go type names
// which reveal package structure. Try various unsupported syntax.
var syntaxTests = [
    ["for (let x of [1]){}", "for-of"],
    ["for (let x in {}){}", "for-in"],
    ["let [a,b] = [1,2]", "destructuring"],
    ["let {...r} = {a:1}", "rest spread"],
    ["var f = (...a) => a", "rest params"],
    ["var [a=1] = []", "default destructure"],
    ["var {a: b} = {a:1}", "rename destructure"],
    ["import 'x'", "import"],
    ["export default 1", "export"],
    ["var x = `hello`", "template literal"],
    ["var x = 0b1010", "binary literal"],
    ["var x = 0o17", "octal literal"],
    ["for await (let x of []) {}", "for-await"],
    ["var x = a?.b", "optional chain"],
    ["var x = a ?? b", "nullish coalesce"],
];
var si = 0;
while (si < syntaxTests.length) {
    try {
        eval(syntaxTests[si][0]);
        _print("  " + syntaxTests[si][1] + ": OK (supported)");
    } catch(e) {
        var msg = String(e);
        // Check for Go type leaks
        if (msg.indexOf("*ast.") >= 0 || msg.indexOf("*parser.") >= 0 || msg.indexOf("unsupported") >= 0) {
            _print("  [!] " + syntaxTests[si][1] + ": " + msg);
        } else {
            _print("  " + syntaxTests[si][1] + ": " + msg.substring(0, 80));
        }
    }
    si++;
}

_print("\n=== Vector 2: Constructor confusion ===");
// Replace .constructor on prototypes to confuse internal checks
// that use constructor to create result objects
try {
    // RegExp[Symbol.species] or RegExp constructor checks
    var origArrayCtor = Array.prototype.constructor;
    Array.prototype.constructor = function FakeArray() {
        _print("    [!] FakeArray constructor called");
        return {};
    };

    // Array.from, map, filter, etc. use constructor internally
    var arr2 = [1,2,3];
    try {
        var mapped = arr2.map(function(x) { return x * 2; });
        _print("  map result type: " + typeof mapped + " keys: " + Object.getOwnPropertyNames(mapped));
    } catch(e2) { _print("  map error: " + e2); }

    // Restore
    Array.prototype.constructor = origArrayCtor;
} catch(e) {
    _print("  constructor confusion error: " + e);
}

_print("\n=== Vector 3: Iterator protocol abuse ===");
// Custom iterator that returns Symbols → does the consumer call ToPropertyKey()?
try {
    var iterObj = {};
    var iterCount = 0;
    iterObj[Symbol.iterator] = function() {
        return {
            next: function() {
                iterCount++;
                if (iterCount <= 3) {
                    return {value: Symbol("iter_" + iterCount), done: false};
                }
                return {done: true};
            }
        };
    };

    // Spread into array
    try {
        var spread = Array.from(iterObj);
        _print("  Array.from(iterable): length=" + spread.length);
        var si2 = 0;
        while (si2 < spread.length) {
            _print("    [" + si2 + "]: type=" + typeof spread[si2] + " val=" + String(spread[si2]));
            si2++;
        }
    } catch(e3) { _print("  Array.from error: " + e3); }
} catch(e) {
    _print("  iterator error: " + e);
}

_print("\n=== Vector 4: JSON.stringify with symbol-keyed properties ===");
// Check if JSON.stringify leaks symbol keys through replacer
try {
    var obj4 = {};
    var sym4 = Symbol("json_leak");
    obj4[sym4] = "secret_value";
    obj4["normal"] = "visible";

    // Get the symbol key string
    var allKeys = Object.getOwnPropertyNames(obj4);
    _print("  All keys: " + allKeys.length);
    var symKeyStr = null;
    var ki = 0;
    while (ki < allKeys.length) {
        if (allKeys[ki].indexOf("@@sym") >= 0) {
            symKeyStr = allKeys[ki];
            _print("  Symbol key found: " + symKeyStr);
        }
        ki++;
    }

    // Try to include symbol key in replacer array
    if (symKeyStr) {
        var json4 = JSON.stringify(obj4, [symKeyStr, "normal"]);
        _print("  JSON with replacer array: " + json4);
        if (json4 && json4.indexOf("@@sym") >= 0) {
            _print("  [!] Symbol key leaked into JSON output!");
        }
    }

    // Try with replacer function
    var seen = [];
    var json4b = JSON.stringify(obj4, function(key, value) {
        seen.push(key);
        return value;
    });
    _print("  Replacer saw keys: " + seen);
    _print("  JSON result: " + json4b);
} catch(e) {
    _print("  JSON error: " + e);
}

_print("\n=== Vector 5: Getters on prototype that read Go internals ===");
// If we define getters on Object.prototype that are called during
// internal operations, we might observe intermediate state
try {
    var observedThis = [];
    Object.defineProperty(Object.prototype, "__spy__", {
        get: function() {
            observedThis.push(typeof this + ":" + String(this).substring(0, 40));
            return undefined;
        },
        configurable: true
    });

    // Trigger operations that create temporary internal objects
    var temp = JSON.parse('{"a": 1}');
    temp.__spy__;

    var arr5 = [1,2,3].map(function(x) { return x; });
    arr5.__spy__;

    try { new RegExp("a").__spy__; } catch(e5) {}

    _print("  Observed this values: " + observedThis.length);
    var oi = 0;
    while (oi < observedThis.length) {
        _print("    " + observedThis[oi]);
        oi++;
    }

    // Clean up
    delete Object.prototype.__spy__;
} catch(e) {
    _print("  getter spy error: " + e);
}

_print("\n=== Vector 6: Type coercion chain ===");
// Complex type coercion that goes through multiple paths
try {
    var coercionTarget = {
        [Symbol.toPrimitive]: function(hint) {
            _print("    toPrimitive called with hint: " + hint);
            if (hint === "number") return 0xDEAD;
            if (hint === "string") return "0xBEEF";
            return true;
        }
    };

    _print("  +obj: " + (+coercionTarget));
    _print("  ''+obj: " + (''+coercionTarget));
    _print("  obj==1: " + (coercionTarget == 1));
} catch(e) {
    _print("  coercion error: " + e);
}

_print("\n=== Vector 7: String + number precision leak ===");
// Go uses fmt.Sprintf("%g") for number→string conversion
// Does it leak more precision than V8?
_print("  0.1+0.2: " + (0.1+0.2));
_print("  1/3: " + (1/3));
_print("  Number.EPSILON: " + Number.EPSILON);
_print("  Math.PI: " + Math.PI);
_print("  Number.MAX_VALUE: " + Number.MAX_VALUE);
_print("  5e-324: " + 5e-324);
_print("  Number.MAX_SAFE_INTEGER: " + Number.MAX_SAFE_INTEGER);
_print("  2**53: " + Math.pow(2, 53));
_print("  2**53+1: " + (Math.pow(2, 53)+1));
// Does %g produce different output than V8? Could fingerprint the engine

_print("\n=== Vector 8: Try to access .Internal via hasOwnProperty ===");
try {
    var m = new Map();
    m.set("a", 1);
    // Internal slots are in Internal map, not Properties
    _print("  Map.hasOwnProperty('entries'): " + m.hasOwnProperty("entries"));
    _print("  Map.hasOwnProperty('size'): " + m.hasOwnProperty("size"));

    // Can we enumerate Internal keys somehow?
    var mkeys = Object.getOwnPropertyNames(m);
    _print("  Map own property names: " + mkeys);

    // Try to access internal slots by name
    _print("  m.entries: " + typeof m.entries);
    _print("  m['entries']: " + m["entries"]);
} catch(e) {
    _print("  Internal access error: " + e);
}

_print("\n=== Vector 9: Abuse type assertion in map via prototype swap ===");
// If we swap a Map's prototype and OType, then use Map methods on it
try {
    // Create a Map
    var realMap = new Map();
    realMap.set("key1", "val1");
    _print("  Map size: " + realMap.size);

    // Create a plain object and give it Map's prototype
    var fakeMap = {};
    Object.setPrototypeOf(fakeMap, Map.prototype);
    // Try calling Map methods on fakeMap
    // This goes through mapGet which calls getMapEntries(this.Object)
    // getMapEntries checks Internal["entries"] → nil → returns nil
    try {
        var getResult = fakeMap.get("key1");
        _print("  fakeMap.get('key1'): " + getResult);
    } catch(e9) { _print("  fakeMap.get error: " + e9); }

    try {
        fakeMap.set("key2", "val2");
        _print("  fakeMap.set: success");
        _print("  fakeMap.get('key2'): " + fakeMap.get("key2"));
    } catch(e9) { _print("  fakeMap.set error: " + e9); }
} catch(e) {
    _print("  prototype swap error: " + e);
}

_print("\n=== Vector 10: Error.stack Go path leak ===");
// Force deep error propagation to get Go source file paths
try {
    function deep(n) {
        if (n <= 0) throw new Error("deep_error");
        return deep(n-1);
    }
    deep(100);
} catch(e) {
    _print("  Deep error: " + e.message);
    _print("  Stack: " + e.stack);
    // Check if stack contains Go paths
    if (e.stack && e.stack.indexOf("/") >= 0) {
        _print("  [!] Stack contains file paths!");
    }
}

// Try to get stack from different error types
try {
    eval("function() {");
} catch(e) {
    _print("  Parse error stack: " + e.stack);
}

_print("\n=== DONE ===");
