// Survey: hunting for additional info leaks and memory leaks
// Tests multiple surfaces for Go runtime information disclosure

_print("=== 1. Error stack property ===");
try { undefined_var; } catch(e) { _print("  stack: " + e.stack); }
try { null.x; } catch(e) { _print("  TypeError stack: " + e.stack); }
try { eval("{"); } catch(e) { _print("  SyntaxError stack: " + e.stack); }

_print("\n=== 2. Function.toString() - closure internals ===");
var secret = "s3cr3t_k3y";
function leakTest() { return secret; }
_print("  toString: " + leakTest.toString());
_print("  bound toString: " + leakTest.bind(null).toString());

_print("\n=== 3. RegExp error messages - Go internals ===");
try { new RegExp("["); } catch(e) { _print("  bad regex: " + e.message); }
try { new RegExp("(?P<name>x)"); } catch(e) { _print("  Go-style group: " + e.message); }
try { new RegExp("a{99999999999999}"); } catch(e) { _print("  huge quantifier: " + e.message); }

_print("\n=== 4. typeof / toString on internal objects ===");
_print("  typeof Symbol.iterator: " + typeof Symbol.iterator);
_print("  String(Symbol.iterator): " + String(Symbol.iterator));
var r = /test/g;
_print("  RegExp keys: " + Object.getOwnPropertyNames(r));

_print("\n=== 5. Object.getOwnPropertyNames on builtins ===");
_print("  Object keys: " + Object.getOwnPropertyNames(Object));
_print("  Array.proto keys: " + Object.getOwnPropertyNames(Array.prototype));
_print("  RegExp.proto keys: " + Object.getOwnPropertyNames(RegExp.prototype));

_print("\n=== 6. Constructor .name and .length ===");
var ctors = [Object, Array, String, Number, Boolean, Function, RegExp, Date, Error, Map, Set, Promise, Symbol];
var cnames = ["Object", "Array", "String", "Number", "Boolean", "Function", "RegExp", "Date", "Error", "Map", "Set", "Promise", "Symbol"];
var ci = 0;
while (ci < ctors.length) {
    var c = ctors[ci];
    var allKeys = Object.getOwnPropertyNames(c);
    // Check if any key contains @ (symbol leak) or 0x (address leak)
    var ki = 0;
    while (ki < allKeys.length) {
        if (allKeys[ki].indexOf("0x") >= 0 || allKeys[ki].indexOf("@@") >= 0) {
            _print("  [!] " + cnames[ci] + " has suspicious key: " + allKeys[ki]);
        }
        ki++;
    }
    ci++;
}

_print("\n=== 7. Prototype chain - symbol keys on prototypes ===");
var protos = [Object.prototype, Array.prototype, String.prototype, RegExp.prototype];
var pnames = ["Object.prototype", "Array.prototype", "String.prototype", "RegExp.prototype"];
var pi = 0;
while (pi < protos.length) {
    var pkeys = Object.getOwnPropertyNames(protos[pi]);
    var pki = 0;
    while (pki < pkeys.length) {
        if (pkeys[pki].indexOf("@@sym") >= 0) {
            _print("  [!] " + pnames[pi] + " leaks symbol addr: " + pkeys[pki]);
        }
        pki++;
    }
    pi++;
}

_print("\n=== 8. JSON.stringify edge cases ===");
_print("  undefined: " + JSON.stringify(undefined));
_print("  function: " + JSON.stringify(function(){}));
_print("  symbol: " + JSON.stringify(Symbol("test")));
_print("  NaN: " + JSON.stringify(NaN));
_print("  Infinity: " + JSON.stringify(1/0));

_print("\n=== 9. Number formatting - Go fmt leaks ===");
_print("  MAX_SAFE_INTEGER: " + String(9007199254740991));
_print("  very small: " + String(5e-324));
_print("  very large: " + String(1.7976931348623157e+308));
_print("  -0: " + String(-0));
_print("  1/3: " + String(1/3));

_print("\n=== 10. eval error propagation ===");
try { eval("throw new Error('from eval')"); } catch(e) { _print("  eval error: " + e.message + " stack: " + e.stack); }
try { var f = new Function("throw new Error('from Function')"); f(); } catch(e) { _print("  Function error: " + e.message + " stack: " + e.stack); }
