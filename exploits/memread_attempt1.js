// Attempt 1: String OOB via integer overflow in slice operations
// Target: builtins/string.go substring/slice with float64->int overflow

_print("=== Attempt 1a: substring with overflow indices ===");
var s = "AAAA";
// NaN -> 0, Infinity -> clamped, but what about MAX_SAFE_INTEGER?
try { _print("  substring(0, 1e15): " + s.substring(0, 1e15)); } catch(e) { _print("  " + e); }
try { _print("  substring(-1, 5): " + s.substring(-1, 5)); } catch(e) { _print("  " + e); }
try { _print("  substring(0, NaN): " + s.substring(0, NaN)); } catch(e) { _print("  " + e); }
try { _print("  substring(NaN, NaN): " + s.substring(NaN, NaN)); } catch(e) { _print("  " + e); }

_print("\n=== Attempt 1b: slice with negative overflow ===");
try { _print("  slice(-1e15): '" + s.slice(-1e15) + "'"); } catch(e) { _print("  " + e); }
try { _print("  slice(0, -0): '" + s.slice(0, -0) + "'"); } catch(e) { _print("  " + e); }
try { _print("  slice(0, 0xFFFFFFFF): '" + s.slice(0, 0xFFFFFFFF) + "'"); } catch(e) { _print("  " + e); }

_print("\n=== Attempt 1c: charCodeAt OOB ===");
try { _print("  charCodeAt(-1): " + s.charCodeAt(-1)); } catch(e) { _print("  " + e); }
try { _print("  charCodeAt(100): " + s.charCodeAt(100)); } catch(e) { _print("  " + e); }
try { _print("  charCodeAt(0xFFFFFFFF): " + s.charCodeAt(0xFFFFFFFF)); } catch(e) { _print("  " + e); }
try { _print("  charCodeAt(NaN): " + s.charCodeAt(NaN)); } catch(e) { _print("  " + e); }

_print("\n=== Attempt 1d: codePointAt OOB ===");
try { _print("  codePointAt(-1): " + s.codePointAt(-1)); } catch(e) { _print("  " + e); }
try { _print("  codePointAt(1e15): " + s.codePointAt(1e15)); } catch(e) { _print("  " + e); }

_print("\n=== Attempt 2: Array sparse access for uninit data ===");
var a = new Array(10);
var ai = 0;
while (ai < 10) {
    var v = a[ai];
    if (v !== undefined) {
        _print("  [!] a[" + ai + "] = " + v + " (type: " + typeof v + ")");
    }
    ai++;
}
_print("  All sparse slots are undefined (Go zeroes memory)");

_print("\n=== Attempt 3: String.fromCharCode edge cases ===");
try { _print("  fromCharCode(0): '" + String.fromCharCode(0) + "' len=" + String.fromCharCode(0).length); } catch(e) { _print("  " + e); }
try { _print("  fromCharCode(-1): '" + String.fromCharCode(-1) + "' code=" + String.fromCharCode(-1).charCodeAt(0)); } catch(e) { _print("  " + e); }
try { _print("  fromCharCode(0xFFFF): code=" + String.fromCharCode(0xFFFF).charCodeAt(0)); } catch(e) { _print("  " + e); }
try { _print("  fromCharCode(0x10000): code=" + String.fromCharCode(0x10000).charCodeAt(0)); } catch(e) { _print("  " + e); }
try { _print("  fromCharCode(NaN): '" + String.fromCharCode(NaN) + "'"); } catch(e) { _print("  " + e); }
try { _print("  fromCharCode(1e15): code=" + String.fromCharCode(1e15).charCodeAt(0)); } catch(e) { _print("  " + e); }
